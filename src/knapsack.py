class backpack:
    """ 背包九讲系列算法

        本类包含基本的背包九讲中各个问题的解法，不同类型的背包问题的参数一般是物品/分组个数、背包体积、物品信息
        返回值除了输出最优解外，还会输出最优解方案数、具体方案
    """
    #01背包 二维空间 朴素解法
    def backpack_01_simple(self,n,v,goods):
        """
        01背包 二维空间 朴素解法\n
        dp使用二维数组\n
        有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。\n
        第 i 件物品的体积是 vi，价值是 wi。\n
        求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n
        输出最大价值。\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.backpack_01_simple(4, 5, [{'v': 1, 'w': 2}, {'v': 2, 'w': 4}, {'v': 3, 'w': 4}, {'v': 4, 'w': 5}])
        8
        >>> b.backpack_01_simple(10, 100, [{'v': 5, 'w': 8}, {'v': 32, 'w': 47}, {'v': 17, 'w': 43}, {'v': 7, 'w': 9}, {'v': 6, 'w': 4}, {'v': 29, 'w': 40}, {'v': 2, 'w': 6}, {'v': 14, 'w': 31}, {'v': 6, 'w': 17}, {'v': 1, 'w': 3}])
        184
        >>> b.backpack_01_simple(20, 200, [{'v': 24, 'w': 50}, {'v': 42, 'w': 60}, {'v': 20, 'w': 49}, {'v': 7, 'w': 15}, {'v': 48, 'w': 115}, {'v': 4, 'w': 11}, {'v': 3, 'w': 8}, {'v': 7, 'w': 5}, {'v': 52, 'w': 66}, {'v': 50, 'w': 25}, {'v': 5, 'w': 8}, {'v': 9, 'w': 25}, {'v': 14, 'w': 40}, {'v': 9, 'w': 22}, {'v': 55, 'w': 42}, {'v': 40, 'w': 30}, {'v': 35, 'w': 49}, {'v': 33, 'w': 16}, {'v': 12, 'w': 12}, {'v': 65, 'w': 127}])
        454
        """
        dp = [([0] * (v+5)) for _ in range(n+5)]
        for i in range(1,n+1):
            for j in range(1,v+1):
                dp[i][j] = dp[i-1][j]
                if j>=goods[i-1]['v']:
                    dp[i][j] = max(dp[i-1][j-goods[i-1]['v']]+goods[i-1]['w'],dp[i][j])
        print(dp[n][v])
    #01背包 一维空间优化
    def backpack_01(self,n,v,goods):
        """
        01背包 一维空间优化\n
        dp使用一维数组进行优化\n
        有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。\n
        第 i 件物品的体积是 vi，价值是 wi。\n
        求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n
        输出最大价值。\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.backpack_01(4, 5, [{'v': 1, 'w': 2}, {'v': 2, 'w': 4}, {'v': 3, 'w': 4}, {'v': 4, 'w': 5}])
        8
        >>> b.backpack_01(10, 100, [{'v': 5, 'w': 8}, {'v': 32, 'w': 47}, {'v': 17, 'w': 43}, {'v': 7, 'w': 9}, {'v': 6, 'w': 4}, {'v': 29, 'w': 40}, {'v': 2, 'w': 6}, {'v': 14, 'w': 31}, {'v': 6, 'w': 17}, {'v': 1, 'w': 3}])
        184
        >>> b.backpack_01(20, 200, [{'v': 24, 'w': 50}, {'v': 42, 'w': 60}, {'v': 20, 'w': 49}, {'v': 7, 'w': 15}, {'v': 48, 'w': 115}, {'v': 4, 'w': 11}, {'v': 3, 'w': 8}, {'v': 7, 'w': 5}, {'v': 52, 'w': 66}, {'v': 50, 'w': 25}, {'v': 5, 'w': 8}, {'v': 9, 'w': 25}, {'v': 14, 'w': 40}, {'v': 9, 'w': 22}, {'v': 55, 'w': 42}, {'v': 40, 'w': 30}, {'v': 35, 'w': 49}, {'v': 33, 'w': 16}, {'v': 12, 'w': 12}, {'v': 65, 'w': 127}])
        454
        """
        dp = [0] * (v+5)
        for i in range(n):
            for j in range(v,0,-1):
                if j>=goods[i]['v']:
                    dp[j] = max(dp[j-goods[i]['v']]+goods[i]['w'],dp[j])
        print(dp[v])
    #完全背包 二维空间 朴素解法
    def full_backpack_simple(self,n,v,goods):
        """
        完全背包 二维空间 朴素解法\n
        dp使用朴素二维空间\n
        有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。\n
        第 i 种物品的体积是 vi，价值是 wi。\n
        求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n
        输出最大价值\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.full_backpack_simple(4, 5, [{'v': 1, 'w': 2}, {'v': 2, 'w': 4}, {'v': 3, 'w': 4}, {'v': 4, 'w': 5}])
        10
        >>> b.full_backpack_simple(10, 100, [{'v': 5, 'w': 8}, {'v': 32, 'w': 47}, {'v': 17, 'w': 43}, {'v': 7, 'w': 9}, {'v': 6, 'w': 4}, {'v': 29, 'w': 40}, {'v': 2, 'w': 6}, {'v': 14, 'w': 31}, {'v': 6, 'w': 17}, {'v': 1, 'w': 3}])
        300
        >>> b.full_backpack_simple(20, 200, [{'v': 24, 'w': 50}, {'v': 42, 'w': 60}, {'v': 20, 'w': 49}, {'v': 7, 'w': 15}, {'v': 48, 'w': 115}, {'v': 4, 'w': 11}, {'v': 3, 'w': 8}, {'v': 7, 'w': 5}, {'v': 52, 'w': 66}, {'v': 50, 'w': 25}, {'v': 5, 'w': 8}, {'v': 9, 'w': 25}, {'v': 14, 'w': 40}, {'v': 9, 'w': 22}, {'v': 55, 'w': 42}, {'v': 40, 'w': 30}, {'v': 35, 'w': 49}, {'v': 33, 'w': 16}, {'v': 12, 'w': 12}, {'v': 65, 'w': 127}])
        571
        """
        dp = [([0] * (v+5)) for _ in range(n+5)]
        for i in range(n):
            for j in range(1,v+1):
                dp[i][j] = dp[i-1][j]
                if j>=goods[i]['v']:
                    dp[i][j] = max(dp[i][j-goods[i]['v']]+goods[i]['w'],dp[i][j])
        print(dp[n-1][v])
    #完全背包 一维空间优化
    def full_backpack(n,v,goods):
        """
        完全背包 一维空间优化\n
        dp使用一维空间优化\n
        有 N 种物品和一个容量是 V 的背包，每种物品都有无限件可用。\n
        第 i 种物品的体积是 vi，价值是 wi。\n
        求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n
        输出最大价值\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.full_backpack_simple(4, 5, [{'v': 1, 'w': 2}, {'v': 2, 'w': 4}, {'v': 3, 'w': 4}, {'v': 4, 'w': 5}])
        10
        >>> b.full_backpack_simple(10, 100, [{'v': 5, 'w': 8}, {'v': 32, 'w': 47}, {'v': 17, 'w': 43}, {'v': 7, 'w': 9}, {'v': 6, 'w': 4}, {'v': 29, 'w': 40}, {'v': 2, 'w': 6}, {'v': 14, 'w': 31}, {'v': 6, 'w': 17}, {'v': 1, 'w': 3}])
        300
        >>> b.full_backpack_simple(20, 200, [{'v': 24, 'w': 50}, {'v': 42, 'w': 60}, {'v': 20, 'w': 49}, {'v': 7, 'w': 15}, {'v': 48, 'w': 115}, {'v': 4, 'w': 11}, {'v': 3, 'w': 8}, {'v': 7, 'w': 5}, {'v': 52, 'w': 66}, {'v': 50, 'w': 25}, {'v': 5, 'w': 8}, {'v': 9, 'w': 25}, {'v': 14, 'w': 40}, {'v': 9, 'w': 22}, {'v': 55, 'w': 42}, {'v': 40, 'w': 30}, {'v': 35, 'w': 49}, {'v': 33, 'w': 16}, {'v': 12, 'w': 12}, {'v': 65, 'w': 127}])
        571
        """
        dp = [0] * (v+5)
        for i in range(n):
            for j in range(1,v+1):
                if j>=goods[i]['v']:
                    dp[j] = max(dp[j-goods[i]['v']]+goods[i]['w'],dp[j])
        print(dp[v])
    #多重背包 朴素三重循环
    def multiple_backpack_simple(self,n,v,goods):
        """
        多重背包 朴素三重循环\n
        使用三层for循环，暴力推出每种物品的数量\n
        有 N 种物品和一个容量是 V 的背包。\n
        第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。\n
        求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。\n
        输出最大价值。\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w,'num':num}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
            good['num'](int): 物品数量
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.multiple_backpack_simple(4, 5, [{'v': 1, 'w': 2, 'num': 3}, {'v': 2, 'w': 4, 'num': 1}, {'v': 3, 'w': 4, 'num': 3}, {'v': 4, 'w': 5, 'num': 2}])
        10
        >>> b.multiple_backpack_simple(10, 100, [{'v': 10, 'w': 17, 'num': 3}, {'v': 9, 'w': 15, 'num': 3}, {'v': 9, 'w': 9, 'num': 1}, {'v': 14, 'w': 28, 'num': 5}, {'v': 18, 'w': 20, 'num': 4}, {'v': 6, 'w': 12, 'num': 5}, {'v': 21, 'w': 32, 'num': 4}, {'v': 19, 'w': 25, 'num': 3}, {'v': 24, 'w': 28, 'num': 2}, {'v': 24, 'w': 34, 'num': 2}])
        200
        >>> b.multiple_backpack_simple(20, 100, [{'v': 7, 'w': 5, 'num': 64}, {'v': 4, 'w': 2, 'num': 13}, {'v': 24, 'w': 15, 'num': 91}, {'v': 8, 'w': 10, 'num': 1}, {'v': 24, 'w': 21, 'num': 4}, {'v': 19, 'w': 21, 'num': 2}, {'v': 31, 'w': 32, 'num': 5}, {'v': 3, 'w': 3, 'num': 5}, {'v': 10, 'w': 18, 'num': 3}, {'v': 29, 'w': 38, 'num': 2}, {'v': 16, 'w': 25, 'num': 4}, {'v': 23, 'w': 20, 'num': 37}, {'v': 8, 'w': 12, 'num': 3}, {'v': 29, 'w': 30, 'num': 5}, {'v': 21, 'w': 37, 'num': 1}, {'v': 26, 'w': 51, 'num': 4}, {'v': 3, 'w': 4, 'num': 1}, {'v': 33, 'w': 26, 'num': 24}, {'v': 10, 'w': 14, 'num': 3}, {'v': 6, 'w': 5, 'num': 11}])
        190
        >>> b.multiple_backpack_simple(30, 100, [{'v': 12, 'w': 15, 'num': 1}, {'v': 15, 'w': 18, 'num': 1}, {'v': 6, 'w': 9, 'num': 4}, {'v': 32, 'w': 43, 'num': 1}, {'v': 24, 'w': 12, 'num': 92}, {'v': 5, 'w': 5, 'num': 3}, {'v': 13, 'w': 26, 'num': 4}, {'v': 2, 'w': 3, 'num': 3}, {'v': 14, 'w': 9, 'num': 7}, {'v': 31, 'w': 28, 'num': 77}, {'v': 19, 'w': 18, 'num': 88}, {'v': 18, 'w': 17, 'num': 70}, {'v': 21, 'w': 23, 'num': 4}, {'v': 19, 'w': 24, 'num': 3}, {'v': 29, 'w': 37, 'num': 2}, {'v': 33, 'w': 34, 'num': 4}, {'v': 25, 'w': 32, 'num': 5}, {'v': 28, 'w': 47, 'num': 4}, {'v': 1, 'w': 1, 'num': 2}, {'v': 23, 'w': 25, 'num': 3}, {'v': 24, 'w': 30, 'num': 1}, {'v': 22, 'w': 24, 'num': 1}, {'v': 4, 'w': 7, 'num': 1}, {'v': 33, 'w': 40, 'num': 2}, {'v': 15, 'w': 29, 'num': 4}, {'v': 18, 'w': 9, 'num': 51}, {'v': 19, 'w': 17, 'num': 25}, {'v': 6, 'w': 10, 'num': 4}, {'v': 24, 'w': 20, 'num': 15}, {'v': 18, 'w': 23, 'num': 5}])
        195
        """
        dp = [0] * (v + 5)
        for i in range(n):
            for j in range(v,0,-1):
                for k in range(1,goods[i]['num']+1):
                    if j>=k*goods[i]['v']:
                        dp[j] = max(dp[j-k*goods[i]['v']]+k*goods[i]['w'],dp[j])
        print(dp[v])
    #多重背包 二进制优化
    def multiple_backpack_Binary(self,n,v,goods):
        """
        多重背包 二进制优化\n
        使用二进制优化，将每种物品的数量拆分成2的n次方表示，并转化为01背包\n
        有 N 种物品和一个容量是 V 的背包。\n
        第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。\n
        求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。\n
        输出最大价值。\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w,'num':num}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
            good['num'](int): 物品数量
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.multiple_backpack_Binary(4, 5, [{'v': 1, 'w': 2, 'num': 3}, {'v': 2, 'w': 4, 'num': 1}, {'v': 3, 'w': 4, 'num': 3}, {'v': 4, 'w': 5, 'num': 2}])
        10
        >>> b.multiple_backpack_Binary(10, 100, [{'v': 10, 'w': 17, 'num': 3}, {'v': 9, 'w': 15, 'num': 3}, {'v': 9, 'w': 9, 'num': 1}, {'v': 14, 'w': 28, 'num': 5}, {'v': 18, 'w': 20, 'num': 4}, {'v': 6, 'w': 12, 'num': 5}, {'v': 21, 'w': 32, 'num': 4}, {'v': 19, 'w': 25, 'num': 3}, {'v': 24, 'w': 28, 'num': 2}, {'v': 24, 'w': 34, 'num': 2}])
        200
        >>> b.multiple_backpack_Binary(20, 100, [{'v': 7, 'w': 5, 'num': 64}, {'v': 4, 'w': 2, 'num': 13}, {'v': 24, 'w': 15, 'num': 91}, {'v': 8, 'w': 10, 'num': 1}, {'v': 24, 'w': 21, 'num': 4}, {'v': 19, 'w': 21, 'num': 2}, {'v': 31, 'w': 32, 'num': 5}, {'v': 3, 'w': 3, 'num': 5}, {'v': 10, 'w': 18, 'num': 3}, {'v': 29, 'w': 38, 'num': 2}, {'v': 16, 'w': 25, 'num': 4}, {'v': 23, 'w': 20, 'num': 37}, {'v': 8, 'w': 12, 'num': 3}, {'v': 29, 'w': 30, 'num': 5}, {'v': 21, 'w': 37, 'num': 1}, {'v': 26, 'w': 51, 'num': 4}, {'v': 3, 'w': 4, 'num': 1}, {'v': 33, 'w': 26, 'num': 24}, {'v': 10, 'w': 14, 'num': 3}, {'v': 6, 'w': 5, 'num': 11}])
        190
        >>> b.multiple_backpack_Binary(30, 100, [{'v': 12, 'w': 15, 'num': 1}, {'v': 15, 'w': 18, 'num': 1}, {'v': 6, 'w': 9, 'num': 4}, {'v': 32, 'w': 43, 'num': 1}, {'v': 24, 'w': 12, 'num': 92}, {'v': 5, 'w': 5, 'num': 3}, {'v': 13, 'w': 26, 'num': 4}, {'v': 2, 'w': 3, 'num': 3}, {'v': 14, 'w': 9, 'num': 7}, {'v': 31, 'w': 28, 'num': 77}, {'v': 19, 'w': 18, 'num': 88}, {'v': 18, 'w': 17, 'num': 70}, {'v': 21, 'w': 23, 'num': 4}, {'v': 19, 'w': 24, 'num': 3}, {'v': 29, 'w': 37, 'num': 2}, {'v': 33, 'w': 34, 'num': 4}, {'v': 25, 'w': 32, 'num': 5}, {'v': 28, 'w': 47, 'num': 4}, {'v': 1, 'w': 1, 'num': 2}, {'v': 23, 'w': 25, 'num': 3}, {'v': 24, 'w': 30, 'num': 1}, {'v': 22, 'w': 24, 'num': 1}, {'v': 4, 'w': 7, 'num': 1}, {'v': 33, 'w': 40, 'num': 2}, {'v': 15, 'w': 29, 'num': 4}, {'v': 18, 'w': 9, 'num': 51}, {'v': 19, 'w': 17, 'num': 25}, {'v': 6, 'w': 10, 'num': 4}, {'v': 24, 'w': 20, 'num': 15}, {'v': 18, 'w': 23, 'num': 5}])
        195
        """
        dp = [0] * (v + 5)
        for i in range(n):
            j = 1
            s = goods[i]['num']
            while s-j>0:
                s -= j
                goods.append({'v': goods[i]['v']*j,'w': goods[i]['w']*j,'num':1})
                j *= 2
            goods.append({'v': goods[i]['v'] * s, 'w': goods[i]['w'] * s, 'num': 1})
        del goods[0:n]
        self.backpack_01(len(goods),v,goods)
    #多重背包 单调队列优化
    def multiple_backpack_humdrumQueue(self,n,v,goods):
        # j=k1*goods[i]['v'] +d k1=j/goods[i]['v'] d=j%goods[i]['v']
        #f[i][j]=max( f[i-1] [j-k*goods[i]['v']] +k*goods[i]['w'] ) 其中0<=k<=goods[i]['num']
        #f[i][j]= max( f[i-1][ k1*goods[i]['v']+d -k*goods[i]['v']] + k*goods[i]['w'])   0<=k<=goods[i]['num']
        #f[i][j]= max( f[i-1][ (k1-k)* goods[i]['v']+d] -(k1 -k) *goods[i]['w'] +k1*goods[i]['w'] )  0<=k<=goods[i]['num']
        #(k1-k)-->k
        #f[i][j]= max( f[i-1][ k* goods[i]['v']+d] -k *goods[i]['w'] ) + k1*goods[i]['w']  k1-goods[i]['num']<= k <=k1
        """
        多重背包 单调队列优化\n
        有 N 种物品和一个容量是 V 的背包。\n
        第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。\n
        求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。\n
        输出最大价值。\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w,'num':num}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
            good['num'](int): 物品数量
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.multiple_backpack_humdrumQueue(4, 5, [{'v': 1, 'w': 2, 'num': 3}, {'v': 2, 'w': 4, 'num': 1}, {'v': 3, 'w': 4, 'num': 3}, {'v': 4, 'w': 5, 'num': 2}])
        10
        >>> b.multiple_backpack_humdrumQueue(10, 100, [{'v': 10, 'w': 17, 'num': 3}, {'v': 9, 'w': 15, 'num': 3}, {'v': 9, 'w': 9, 'num': 1}, {'v': 14, 'w': 28, 'num': 5}, {'v': 18, 'w': 20, 'num': 4}, {'v': 6, 'w': 12, 'num': 5}, {'v': 21, 'w': 32, 'num': 4}, {'v': 19, 'w': 25, 'num': 3}, {'v': 24, 'w': 28, 'num': 2}, {'v': 24, 'w': 34, 'num': 2}])
        200
        >>> b.multiple_backpack_humdrumQueue(20, 100, [{'v': 7, 'w': 5, 'num': 64}, {'v': 4, 'w': 2, 'num': 13}, {'v': 24, 'w': 15, 'num': 91}, {'v': 8, 'w': 10, 'num': 1}, {'v': 24, 'w': 21, 'num': 4}, {'v': 19, 'w': 21, 'num': 2}, {'v': 31, 'w': 32, 'num': 5}, {'v': 3, 'w': 3, 'num': 5}, {'v': 10, 'w': 18, 'num': 3}, {'v': 29, 'w': 38, 'num': 2}, {'v': 16, 'w': 25, 'num': 4}, {'v': 23, 'w': 20, 'num': 37}, {'v': 8, 'w': 12, 'num': 3}, {'v': 29, 'w': 30, 'num': 5}, {'v': 21, 'w': 37, 'num': 1}, {'v': 26, 'w': 51, 'num': 4}, {'v': 3, 'w': 4, 'num': 1}, {'v': 33, 'w': 26, 'num': 24}, {'v': 10, 'w': 14, 'num': 3}, {'v': 6, 'w': 5, 'num': 11}])
        190
        >>> b.multiple_backpack_humdrumQueue(30, 100, [{'v': 12, 'w': 15, 'num': 1}, {'v': 15, 'w': 18, 'num': 1}, {'v': 6, 'w': 9, 'num': 4}, {'v': 32, 'w': 43, 'num': 1}, {'v': 24, 'w': 12, 'num': 92}, {'v': 5, 'w': 5, 'num': 3}, {'v': 13, 'w': 26, 'num': 4}, {'v': 2, 'w': 3, 'num': 3}, {'v': 14, 'w': 9, 'num': 7}, {'v': 31, 'w': 28, 'num': 77}, {'v': 19, 'w': 18, 'num': 88}, {'v': 18, 'w': 17, 'num': 70}, {'v': 21, 'w': 23, 'num': 4}, {'v': 19, 'w': 24, 'num': 3}, {'v': 29, 'w': 37, 'num': 2}, {'v': 33, 'w': 34, 'num': 4}, {'v': 25, 'w': 32, 'num': 5}, {'v': 28, 'w': 47, 'num': 4}, {'v': 1, 'w': 1, 'num': 2}, {'v': 23, 'w': 25, 'num': 3}, {'v': 24, 'w': 30, 'num': 1}, {'v': 22, 'w': 24, 'num': 1}, {'v': 4, 'w': 7, 'num': 1}, {'v': 33, 'w': 40, 'num': 2}, {'v': 15, 'w': 29, 'num': 4}, {'v': 18, 'w': 9, 'num': 51}, {'v': 19, 'w': 17, 'num': 25}, {'v': 6, 'w': 10, 'num': 4}, {'v': 24, 'w': 20, 'num': 15}, {'v': 18, 'w': 23, 'num': 5}])
        195
        """
        dp = [0] * (v + 5)
        pre = [0] * (v + 5)
        queue = [0]* (v + 5)
        for i in range(n):
           pre = dp.copy()
           good_v = goods[i]['v']
           good_num = goods[i]['num']
           good_w = goods[i]['w']
           for j in range(good_v):
                head = 0
                tail = -1
                for k in range(j,v+1,good_v):
                    if head<=tail and k - good_num*good_v > queue[head]:
                        head += 1
                    while head <= tail and pre[queue[tail]] - (queue[tail]-j)/good_v*good_w<= pre[k] - (k-j)/good_v*good_w:
                        tail -= 1
                    if head<=tail:
                        dp[k] = max(dp[k],pre[queue[head]]+(k-queue[head])/good_v*good_w)
                    tail += 1
                    queue[tail] = k
        print(int(dp[v]))
    #混合背包
    def mix_backpack(self,n,v,goods):
        """
        混合背包\n
        前面几种背包问题的结合\n
        有 N 种物品和一个容量是 V 的背包。\n
        物品一共有三类：\n
        第一类物品只能用1次（01背包）；\n
        第二类物品可以用无限次（完全背包）；\n
        第三类物品最多只能用 si 次（多重背包）；\n
        每种体积是 vi，价值是 wi。\n
        求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。\n
        输出最大价值。\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w,'type':type}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
            good['type'](int): 物品类型，type=-1 表示只能用一次；type=0 表示可以用无限次；type>0 表示只能用一次；
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.mix_backpack(4, 5, [{'v': 1, 'w': 2, 'type': -1}, {'v': 2, 'w': 4, 'type': 1}, {'v': 3, 'w': 4, 'type': 0}, {'v': 4, 'w': 5, 'type': 2}])
        8
        >>> b.mix_backpack(10, 10, [{'v': 3, 'w': 7, 'type': 10}, {'v': 1, 'w': 8, 'type': 10}, {'v': 2, 'w': 4, 'type': 10}, {'v': 3, 'w': 10, 'type': 10}, {'v': 1, 'w': 2, 'type': 10}, {'v': 1, 'w': 1, 'type': 10}, {'v': 3, 'w': 6, 'type': 10}, {'v': 2, 'w': 8, 'type': 10}, {'v': 3, 'w': 4, 'type': 10}, {'v': 3, 'w': 2, 'type': 10}])
        80
        >>> b.mix_backpack(20, 50, [{'v': 1, 'w': 43, 'type': 50}, {'v': 2, 'w': 8, 'type': 50}, {'v': 1, 'w': 26, 'type': 50}, {'v': 1, 'w': 39, 'type': 50}, {'v': 3, 'w': 32, 'type': 50}, {'v': 1, 'w': 49, 'type': 50}, {'v': 2, 'w': 43, 'type': 50}, {'v': 1, 'w': 36, 'type': -1}, {'v': 1, 'w': 14, 'type': 50}, {'v': 2, 'w': 17, 'type': 50}, {'v': 2, 'w': 47, 'type': 50}, {'v': 2, 'w': 49, 'type': 50}, {'v': 1, 'w': 16, 'type': 50}, {'v': 3, 'w': 12, 'type': 50}, {'v': 1, 'w': 36, 'type': 50}, {'v': 1, 'w': 48, 'type': 50}, {'v': 3, 'w': 13, 'type': 50}, {'v': 2, 'w': 49, 'type': 50}, {'v': 1, 'w': 13, 'type': 50}, {'v': 3, 'w': 15, 'type': 50}])
        2450
        >>> b.mix_backpack(30, 100, [{'v': 1, 'w': 31, 'type': 100}, {'v': 3, 'w': 18, 'type': 100}, {'v': 2, 'w': 52, 'type': 100}, {'v': 2, 'w': 65, 'type': -1}, {'v': 2, 'w': 37, 'type': 100}, {'v': 2, 'w': 76, 'type': 100}, {'v': 2, 'w': 70, 'type': 100}, {'v': 3, 'w': 5, 'type': 100}, {'v': 3, 'w': 53, 'type': 100}, {'v': 3, 'w': 10, 'type': 100}, {'v': 2, 'w': 73, 'type': 100}, {'v': 3, 'w': 3, 'type': 100}, {'v': 1, 'w': 3, 'type': 100}, {'v': 2, 'w': 99, 'type': 100}, {'v': 2, 'w': 53, 'type': -1}, {'v': 2, 'w': 9, 'type': 100}, {'v': 3, 'w': 81, 'type': 100}, {'v': 1, 'w': 68, 'type': 100}, {'v': 3, 'w': 78, 'type': 100}, {'v': 3, 'w': 47, 'type': 100}, {'v': 2, 'w': 62, 'type': 100}, {'v': 3, 'w': 62, 'type': 100}, {'v': 2, 'w': 64, 'type': 100}, {'v': 3, 'w': 87, 'type': 100}, {'v': 2, 'w': 21, 'type': 100}, {'v': 1, 'w': 19, 'type': 100}, {'v': 3, 'w': 20, 'type': 100}, {'v': 2, 'w': 88, 'type': 100}, {'v': 1, 'w': 22, 'type': 100}, {'v': 3, 'w': 75, 'type': -1}])
        6800
        """
        dp = [0] * (v + 5)
        for i in range(n):
            if goods[i]['type']==-1:
                for j in range(v,0,-1):
                    if j>=goods[i]['v']:
                        dp[j] = max(dp[j-goods[i]['v']]+goods[i]['w'],dp[j])
            elif goods[i]['type']==0:
                for j in range(1,v+1):
                    if j>=goods[i]['v']:
                        dp[j] = max(dp[j-goods[i]['v']]+goods[i]['w'],dp[j])
            else:
                j = 1
                s = goods[i]['type']
                goods_copy = []
                while s-j>0:
                    s -= j
                    goods_copy.append((goods[i]['v']*j,goods[i]['w']*j,1))
                    j *= 2
                goods_copy.append((goods[i]['v'] * s, goods[i]['w'] * s, 1))
                for ii in range(len(goods_copy)):
                    for jj in range(v, 0, -1):
                        if jj >= goods_copy[ii][0]:
                            dp[jj] = max(dp[jj - goods_copy[ii][0]] + goods_copy[ii][1], dp[jj])
        print(dp[v])
    #二维背包
    def TD_backpack(self,n,v,m,goods):
        """
        二维背包\n
        有 N 件物品和一个容量是 V 的背包，背包能承受的最大重量是 M。\n
        每件物品只能用一次。体积是 vi，重量是 mi，价值是 wi。\n
        求解将哪些物品装入背包，可使物品总体积不超过背包容量，总重量不超过背包可承受的最大重量，且价值总和最大。\n
        输出最大价值。\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w,'s':s}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
            good['s'](int): 物品重量
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.TD_backpack(4, 5, 6, [{'v': 1, 'w': 3, 's': 2}, {'v': 2, 'w': 4, 's': 4}, {'v': 3, 'w': 5, 's': 4}, {'v': 4, 'w': 6, 's': 5}])
        8
        >>> b.TD_backpack(10, 7, 10, [{'v': 7, 'w': 5, 's': 5}, {'v': 2, 'w': 20, 's': 2}, {'v': 7, 'w': 25, 's': 7}, {'v': 1, 'w': 5, 's': 5}, {'v': 6, 'w': 17, 's': 3}, {'v': 2, 'w': 7, 's': 7}, {'v': 6, 'w': 9, 's': 5}, {'v': 7, 'w': 58, 's': 8}, {'v': 5, 'w': 18, 's': 4}, {'v': 10, 'w': 36, 's': 5}])
        58
        >>> b.TD_backpack(20, 37, 50, [{'v': 48, 'w': 38, 's': 8}, {'v': 43, 'w': 5, 's': 26}, {'v': 38, 'w': 6, 's': 2}, {'v': 29, 'w': 88, 's': 13}, {'v': 22, 'w': 145, 's': 16}, {'v': 10, 'w': 32, 's': 43}, {'v': 20, 'w': 132, 's': 33}, {'v': 19, 'w': 44, 's': 40}, {'v': 36, 'w': 271, 's': 48}, {'v': 2, 'w': 16, 's': 33}, {'v': 43, 'w': 250, 's': 38}, {'v': 48, 'w': 167, 's': 19}, {'v': 11, 'w': 59, 's': 42}, {'v': 21, 'w': 106, 's': 33}, {'v': 13, 'w': 1, 's': 6}, {'v': 32, 'w': 29, 's': 39}, {'v': 48, 'w': 238, 's': 41}, {'v': 15, 'w': 105, 's': 41}, {'v': 32, 'w': 173, 's': 19}, {'v': 5, 'w': 42, 's': 26}])
        271
        >>> b.TD_backpack(30, 75, 100, [{'v': 100, 'w': 65, 's': 98}, {'v': 57, 'w': 21, 's': 6}, {'v': 35, 'w': 46, 's': 33}, {'v': 39, 'w': 308, 's': 33}, {'v': 42, 'w': 44, 's': 10}, {'v': 97, 'w': 316, 's': 72}, {'v': 76, 'w': 599, 's': 74}, {'v': 9, 'w': 57, 's': 22}, {'v': 20, 'w': 39, 's': 39}, {'v': 46, 'w': 238, 's': 40}, {'v': 34, 'w': 154, 's': 43}, {'v': 65, 'w': 436, 's': 45}, {'v': 6, 'w': 16, 's': 24}, {'v': 12, 'w': 74, 's': 77}, {'v': 97, 'w': 164, 's': 17}, {'v': 70, 'w': 465, 's': 57}, {'v': 36, 'w': 13, 's': 4}, {'v': 32, 'w': 98, 's': 95}, {'v': 15, 'w': 98, 's': 72}, {'v': 36, 'w': 121, 's': 89}, {'v': 61, 'w': 58, 's': 28}, {'v': 24, 'w': 45, 's': 14}, {'v': 27, 'w': 257, 's': 90}, {'v': 77, 'w': 291, 's': 41}, {'v': 83, 'w': 643, 's': 79}, {'v': 91, 'w': 291, 's': 67}, {'v': 93, 'w': 1, 's': 2}, {'v': 22, 'w': 191, 's': 71}, {'v': 22, 'w': 124, 's': 73}, {'v': 23, 'w': 9, 's': 10}])
        493
        """
        dp = [([0] * (m + 5)) for _ in range(v + 5)]
        for i in range(n):
            for j in range(v, 0, -1):
                for k in range(m, 0, -1):
                    if j >= goods[i]['v'] and k >= goods[i]['s']:
                        dp[j][k] = max(dp[j - goods[i]['v']][k - goods[i]['s']] + goods[i]['w'], dp[j][k])

        print(dp[v][m])
    #分组背包
    def group_backpack(self,n,v,goods):
        """
        分组背包\n
        有 N 组物品和一个容量是 V 的背包。\n
        每组物品有若干个，同一组内的物品最多只能选一个。\n
        每件物品的体积是 vij，价值是 wij，其中 i 是组号，j 是组内编号。\n
        求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。\n
        输出最大价值。\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w,'group':group}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
            good['group'](int): 物品所属组号
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.group_backpack(3, 5, [{'v': 1, 'w': 2, 'group': 1}, {'v': 2, 'w': 4, 'group': 1}, {'v': 3, 'w': 4, 'group': 2}, {'v': 4, 'w': 5, 'group': 3}])
        8
        >>> b.group_backpack(10, 10, [{'v': 8, 'w': 5, 'group': 1}, {'v': 3, 'w': 6, 'group': 1}, {'v': 10, 'w': 25, 'group': 1}, {'v': 8, 'w': 17, 'group': 1}, {'v': 7, 'w': 15, 'group': 1}, {'v': 2, 'w': 29, 'group': 1}, {'v': 8, 'w': 3, 'group': 1}, {'v': 1, 'w': 2, 'group': 1}, {'v': 2, 'w': 17, 'group': 1}, {'v': 10, 'w': 24, 'group': 1}, {'v': 8, 'w': 2, 'group': 2}, {'v': 1, 'w': 8, 'group': 2}, {'v': 8, 'w': 26, 'group': 2}, {'v': 8, 'w': 17, 'group': 2}, {'v': 5, 'w': 12, 'group': 2}, {'v': 7, 'w': 13, 'group': 2}, {'v': 2, 'w': 17, 'group': 2}, {'v': 8, 'w': 8, 'group': 2}, {'v': 7, 'w': 4, 'group': 2}, {'v': 6, 'w': 1, 'group': 3}, {'v': 1, 'w': 13, 'group': 3}, {'v': 3, 'w': 15, 'group': 3}, {'v': 8, 'w': 8, 'group': 3}, {'v': 6, 'w': 19, 'group': 3}, {'v': 10, 'w': 12, 'group': 3}, {'v': 3, 'w': 17, 'group': 3}, {'v': 5, 'w': 12, 'group': 4}, {'v': 4, 'w': 11, 'group': 4}, {'v': 7, 'w': 10, 'group': 4}, {'v': 10, 'w': 3, 'group': 4}, {'v': 9, 'w': 18, 'group': 4}, {'v': 4, 'w': 12, 'group': 4}, {'v': 2, 'w': 9, 'group': 4}, {'v': 1, 'w': 6, 'group': 5}, {'v': 3, 'w': 5, 'group': 5}, {'v': 3, 'w': 20, 'group': 5}, {'v': 10, 'w': 20, 'group': 5}, {'v': 4, 'w': 9, 'group': 5}, {'v': 5, 'w': 5, 'group': 5}, {'v': 9, 'w': 22, 'group': 5}, {'v': 8, 'w': 23, 'group': 5}, {'v': 7, 'w': 14, 'group': 5}, {'v': 8, 'w': 19, 'group': 6}, {'v': 9, 'w': 1, 'group': 6}, {'v': 8, 'w': 4, 'group': 6}, {'v': 10, 'w': 4, 'group': 6}, {'v': 3, 'w': 17, 'group': 6}, {'v': 8, 'w': 9, 'group': 6}, {'v': 1, 'w': 8, 'group': 6}, {'v': 5, 'w': 26, 'group': 7}, {'v': 1, 'w': 18, 'group': 7}, {'v': 5, 'w': 13, 'group': 7}, {'v': 8, 'w': 19, 'group': 7}, {'v': 1, 'w': 20, 'group': 7}, {'v': 3, 'w': 28, 'group': 7}, {'v': 6, 'w': 21, 'group': 7}, {'v': 2, 'w': 26, 'group': 7}, {'v': 3, 'w': 20, 'group': 7}, {'v': 2, 'w': 30, 'group': 7}, {'v': 9, 'w': 8, 'group': 8}, {'v': 9, 'w': 25, 'group': 8}, {'v': 1, 'w': 18, 'group': 8}, {'v': 7, 'w': 27, 'group': 8}, {'v': 10, 'w': 16, 'group': 8}, {'v': 1, 'w': 10, 'group': 8}, {'v': 7, 'w': 9, 'group': 8}, {'v': 5, 'w': 24, 'group': 8}, {'v': 5, 'w': 4, 'group': 8}, {'v': 3, 'w': 11, 'group': 9}, {'v': 6, 'w': 4, 'group': 9}, {'v': 3, 'w': 9, 'group': 9}, {'v': 2, 'w': 24, 'group': 9}, {'v': 4, 'w': 13, 'group': 9}, {'v': 5, 'w': 18, 'group': 9}, {'v': 2, 'w': 18, 'group': 9}, {'v': 1, 'w': 1, 'group': 9}, {'v': 2, 'w': 3, 'group': 10}, {'v': 5, 'w': 13, 'group': 10}, {'v': 9, 'w': 15, 'group': 10}, {'v': 2, 'w': 2, 'group': 10}, {'v': 2, 'w': 3, 'group': 10}])
        131
        """
        dp = [0] * (v + 5)
        num  = len(goods)
        group = 1
        i = 0
        tmp = 0
        while group<=n:
            for j in range(v,0,-1):
                tmp = i
                while goods[tmp]['group'] == group:
                    if j>=goods[tmp]['v']:
                        dp[j] = max(dp[j-goods[tmp]['v']]+goods[tmp]['w'],dp[j])
                    tmp += 1
                    if tmp>=num:
                        break
            i = tmp
            group += 1
        print(max(dp))
    #依赖背包
    def dfs(self,x,position,goods,dp,n,v):
        for i in range(goods[x-1]['v'],v+1):
            dp[x][i] = goods[x-1]['w']
        for i in position[x]:
            self.dfs(i,position,goods,dp,n,v)
            for j in range(v,goods[x-1]['v']-1,-1):
                for k in range(0,j-goods[x-1]['v']+1):
                    dp[x][j] = max(dp[x][j],dp[x][j-k]+dp[i][k])
    def rely_backpack(self,n,v,goods):
        """
        依赖背包\n
        有 NN 个物品和一个容量是 VV 的背包。\n
        物品之间具有依赖关系，且依赖关系组成一棵树的形状。如果选择一个物品，则必须选择它的父节点。\n
        如果选择物品5，则必须选择物品1和2。这是因为2是5的父节点，1是2的父节点。\n
        每件物品的编号是 ii，体积是 vivi，价值是 wiwi，依赖的父节点编号是 pipi。物品的下标范围是 1…N1…N。\n
        求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。\n
        输出最大价值。\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w,'p':p}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
            good['p'](int): 物品依赖的物品编号，-1表示没有依赖
        Returns:
            int : 最优价值解
        >>> b = backpack()
        >>> b.rely_backpack(5, 7, [{'v': 2, 'w': 3, 'p': -1}, {'v': 2, 'w': 2, 'p': 1}, {'v': 3, 'w': 5, 'p': 1}, {'v': 4, 'w': 7, 'p': 2}, {'v': 3, 'w': 6, 'p': 2}])
        11
        >>> b.rely_backpack(10, 10, [{'v': 3, 'w': 4, 'p': 9}, {'v': 1, 'w': 3, 'p': 3}, {'v': 4, 'w': 5, 'p': 7}, {'v': 5, 'w': 9, 'p': 1}, {'v': 4, 'w': 4, 'p': 10}, {'v': 2, 'w': 3, 'p': 1}, {'v': 2, 'w': 6, 'p': 1}, {'v': 2, 'w': 1, 'p': 1}, {'v': 2, 'w': 1, 'p': -1}, {'v': 4, 'w': 6, 'p': 2}])
        14
        >>> b.rely_backpack(20, 50, [{'v': 18, 'w': 23, 'p': 10}, {'v': 4, 'w': 31, 'p': 10}, {'v': 1, 'w': 27, 'p': 4}, {'v': 22, 'w': 21, 'p': 7}, {'v': 16, 'w': 1, 'p': 10}, {'v': 22, 'w': 31, 'p': 14}, {'v': 7, 'w': 39, 'p': -1}, {'v': 25, 'w': 16, 'p': 3}, {'v': 2, 'w': 40, 'p': 8}, {'v': 7, 'w': 44, 'p': 3}, {'v': 3, 'w': 10, 'p': 3}, {'v': 21, 'w': 45, 'p': 8}, {'v': 20, 'w': 29, 'p': 19}, {'v': 11, 'w': 17, 'p': 4}, {'v': 20, 'w': 46, 'p': 18}, {'v': 14, 'w': 48, 'p': 13}, {'v': 9, 'w': 48, 'p': 8}, {'v': 15, 'w': 21, 'p': 3}, {'v': 5, 'w': 30, 'p': 3}, {'v': 10, 'w': 32, 'p': 18}])
        202
        >>> b.rely_backpack(30, 100, [{'v': 24, 'w': 67, 'p': 15}, {'v': 23, 'w': 20, 'p': 5}, {'v': 18, 'w': 76, 'p': 29}, {'v': 24, 'w': 36, 'p': 7}, {'v': 33, 'w': 53, 'p': 25}, {'v': 14, 'w': 20, 'p': 13}, {'v': 41, 'w': 46, 'p': 13}, {'v': 47, 'w': 100, 'p': 4}, {'v': 12, 'w': 89, 'p': 7}, {'v': 38, 'w': 49, 'p': 25}, {'v': 50, 'w': 21, 'p': 3}, {'v': 38, 'w': 17, 'p': 13}, {'v': 24, 'w': 81, 'p': 29}, {'v': 47, 'w': 72, 'p': 13}, {'v': 25, 'w': 33, 'p': 4}, {'v': 2, 'w': 2, 'p': 19}, {'v': 8, 'w': 10, 'p': 24}, {'v': 14, 'w': 65, 'p': 29}, {'v': 33, 'w': 22, 'p': 24}, {'v': 34, 'w': 60, 'p': 15}, {'v': 3, 'w': 79, 'p': 8}, {'v': 7, 'w': 95, 'p': 3}, {'v': 37, 'w': 17, 'p': 27}, {'v': 20, 'w': 49, 'p': 18}, {'v': 36, 'w': 91, 'p': 29}, {'v': 20, 'w': 41, 'p': 13}, {'v': 37, 'w': 4, 'p': 7}, {'v': 33, 'w': 12, 'p': 4}, {'v': 50, 'w': 14, 'p': -1}, {'v': 9, 'w': 47, 'p': 28}])
        266
        """
        dp = [([0] * (v+5)) for _ in range(n+5)]
        # [{'v':2,'w':3,'p':-1},{'v':2,'w':2,'p':1},{'v':3,'w':5,'p':1},{'v':4,'w':7,'p':2},{'v':3,'w':6,'p':2}]
        #[[], [2, 3], [4, 5], [], [], [], [], [], [], []]
        position = [([]) for _ in range(n+5)]
        root = 0
        for i in range(n):
            if goods[i]['p'] != -1:
                position[goods[i]['p']].append(i+1)
            else:
                root = i+1
        self.dfs(root,position,goods,dp,n,v)
        print(dp[root][v])
    #背包方案数
    def backpack_number_schemes(self,n,v,goods):
        """
        背包方案数\n
        有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。\n
        第 i 件物品的体积是 vi，价值是 wi。\n
        求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n
        输出 最优选法的方案数。\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
        Returns:
            int : 最优价值解的方案个数
        >>> b = backpack()
        >>> b.backpack_number_schemes(4, 5, [{'v': 1, 'w': 2}, {'v': 2, 'w': 4}, {'v': 3, 'w': 4}, {'v': 4, 'w': 6}])
        2
        >>> b.backpack_number_schemes(10, 100, [{'v': 2, 'w': 1}, {'v': 3, 'w': 9}, {'v': 14, 'w': 16}, {'v': 27, 'w': 67}, {'v': 22, 'w': 65}, {'v': 31, 'w': 45}, {'v': 18, 'w': 35}, {'v': 27, 'w': 65}, {'v': 13, 'w': 29}, {'v': 33, 'w': 85}])
        1
        >>> b.backpack_number_schemes(20, 200, [{'v': 60, 'w': 96}, {'v': 29, 'w': 60}, {'v': 30, 'w': 77}, {'v': 19, 'w': 55}, {'v': 18, 'w': 32}, {'v': 2, 'w': 4}, {'v': 4, 'w': 7}, {'v': 59, 'w': 152}, {'v': 64, 'w': 96}, {'v': 42, 'w': 25}, {'v': 14, 'w': 9}, {'v': 28, 'w': 21}, {'v': 48, 'w': 113}, {'v': 14, 'w': 21}, {'v': 18, 'w': 31}, {'v': 57, 'w': 143}, {'v': 63, 'w': 126}, {'v': 26, 'w': 52}, {'v': 6, 'w': 6}, {'v': 37, 'w': 75}])
        1
        >>> b.backpack_number_schemes(30, 300, [{'v': 39, 'w': 29}, {'v': 51, 'w': 40}, {'v': 16, 'w': 38}, {'v': 74, 'w': 143}, {'v': 56, 'w': 120}, {'v': 5, 'w': 5}, {'v': 61, 'w': 104}, {'v': 92, 'w': 124}, {'v': 27, 'w': 79}, {'v': 50, 'w': 52}, {'v': 76, 'w': 83}, {'v': 15, 'w': 40}, {'v': 56, 'w': 88}, {'v': 99, 'w': 173}, {'v': 49, 'w': 105}, {'v': 100, 'w': 171}, {'v': 27, 'w': 48}, {'v': 16, 'w': 45}, {'v': 100, 'w': 152}, {'v': 98, 'w': 92}, {'v': 6, 'w': 14}, {'v': 1, 'w': 1}, {'v': 52, 'w': 149}, {'v': 40, 'w': 105}, {'v': 14, 'w': 8}, {'v': 58, 'w': 150}, {'v': 54, 'w': 126}, {'v': 59, 'w': 169}, {'v': 93, 'w': 233}, {'v': 37, 'w': 88}])
        2
        """
        dp = [float("-inf")] * (v+5)
        num = [0] * (v+5)
        num[0] = 1
        dp[0] = 0
        # print(num)
        for i in range(n):
            for j in range(v,goods[i]['v']-1,-1):
                    if dp[j-goods[i]['v']]+goods[i]['w']>dp[j]:
                        dp[j] = dp[j-goods[i]['v']]+goods[i]['w']
                        num[j] = num[j-goods[i]['v']]
                    elif dp[j-goods[i]['v']]+goods[i]['w']==dp[j]:
                        num[j] += num[j - goods[i]['v']]
        m = max(dp)
        res = 0
        for i in range(len(dp)):
            if dp[i]==m:
                res += num[i]
        print(res)
    #背包具体方案
    def backpack_programme(self,n,v,goods):
        """
        背包方案数\n
        有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。\n
        第 i 件物品的体积是 vi，价值是 wi。\n
        求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。\n
        输出 具体方案\n
        Args:
            n(int): 物品数量
            v(int): 背包体积
            goods([]): 物品信息队列 物品字典为{'v':v,'w':w}
            good['v'](int): 物品体积
            good['w'](int): 物品价值
        Returns:
            int : 最优价值解的方案个数
        >>> b = backpack()
        >>> b.backpack_programme(4, 5, [{'v': 1, 'w': 2}, {'v': 2, 'w': 4}, {'v': 3, 'w': 4}, {'v': 4, 'w': 6}])
        1 4
        >>> b.backpack_programme(10, 100, [{'v': 12, 'w': 10}, {'v': 11, 'w': 19}, {'v': 18, 'w': 12}, {'v': 33, 'w': 89}, {'v': 10, 'w': 14}, {'v': 14, 'w': 28}, {'v': 8, 'w': 13}, {'v': 20, 'w': 40}, {'v': 27, 'w': 24}, {'v': 4, 'w': 5}])
        2 4 5 6 7 8 10
        >>> b.backpack_programme(20, 200, [{'v': 29, 'w': 37}, {'v': 54, 'w': 129}, {'v': 42, 'w': 126}, {'v': 10, 'w': 19}, {'v': 1, 'w': 1}, {'v': 57, 'w': 143}, {'v': 5, 'w': 15}, {'v': 35, 'w': 97}, {'v': 52, 'w': 135}, {'v': 61, 'w': 52}, {'v': 26, 'w': 14}, {'v': 16, 'w': 28}, {'v': 13, 'w': 11}, {'v': 62, 'w': 157}, {'v': 22, 'w': 30}, {'v': 55, 'w': 87}, {'v': 56, 'w': 154}, {'v': 21, 'w': 40}, {'v': 25, 'w': 55}, {'v': 33, 'w': 19}])
        3 7 8 14 17
        >>> b.backpack_programme(30, 300, [{'v': 59, 'w': 113}, {'v': 92, 'w': 144}, {'v': 95, 'w': 74}, {'v': 6, 'w': 3}, {'v': 44, 'w': 89}, {'v': 8, 'w': 11}, {'v': 77, 'w': 214}, {'v': 60, 'w': 169}, {'v': 37, 'w': 110}, {'v': 49, 'w': 127}, {'v': 21, 'w': 36}, {'v': 57, 'w': 80}, {'v': 84, 'w': 49}, {'v': 16, 'w': 33}, {'v': 27, 'w': 69}, {'v': 57, 'w': 78}, {'v': 70, 'w': 193}, {'v': 47, 'w': 131}, {'v': 16, 'w': 11}, {'v': 44, 'w': 75}, {'v': 44, 'w': 39}, {'v': 93, 'w': 89}, {'v': 74, 'w': 190}, {'v': 34, 'w': 100}, {'v': 78, 'w': 207}, {'v': 2, 'w': 5}, {'v': 74, 'w': 181}, {'v': 25, 'w': 38}, {'v': 46, 'w': 104}, {'v': 55, 'w': 85}])
        8 9 10 17 18 24 26
        """
        res = []
        dp = [([0] * (v+5)) for _ in range(n+5)]
        for i in range(1,n+1):
            for j in range(v,0,-1):
                dp[i][j] = dp[i-1][j]
                if j>=goods[i-1]['v']:
                    dp[i][j] = max(dp[i-1][j-goods[i-1]['v']]+goods[i-1]['w'],dp[i][j])
        val = v
        for i in range(n-1,-1,-1):
            if val-goods[i]['v']>=0 and dp[i+1][val] == dp[i][val-goods[i]['v']]+goods[i]['w']:
                res.append(i+1)
                val -= goods[i]['v']
        res = res[::-1]
        for i in range(len(res)-1):
            print(res[i], end=" ")
        print(res[len(res)-1])
if __name__ == '__main__':
    import doctest
    # doctest.testmod(verbose=True)
    doctest.testmod()
